package main

import (
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq"
)

func main() {
	// Use the Railway database URL
	dbURL := "postgresql://postgres:jTKOWGEzlprRGbkPBCgGxsgnwyLeGoDL@shortline.proxy.rlwy.net:40148/railway"

	db, err := sqlx.Open("postgres", dbURL)
	if err != nil {
		log.Fatal("Failed to connect:", err)
	}
	defer db.Close()

	if err := db.Ping(); err != nil {
		log.Fatal("Failed to ping:", err)
	}
	fmt.Println("Connected to Railway database")

	// Create output file
	file, err := os.Create("railway_export.sql")
	if err != nil {
		log.Fatal("Failed to create export file:", err)
	}
	defer file.Close()

	// Write header
	file.WriteString("-- Railway Database Export\n")
	file.WriteString("-- Generated by export_railway_data.go\n\n")

	// Get all tables
	var tables []string
	err = db.Select(&tables, `
		SELECT tablename 
		FROM pg_tables 
		WHERE schemaname = 'public' 
		ORDER BY tablename
	`)
	if err != nil {
		log.Fatal("Failed to get tables:", err)
	}

	fmt.Printf("Found %d tables to export\n", len(tables))

	// Export each table
	for _, table := range tables {
		fmt.Printf("Exporting table: %s\n", table)
		
		// Write table comment
		file.WriteString(fmt.Sprintf("\n-- Table: %s\n", table))
		
		// Get table structure
		var createStmt string
		err = db.Get(&createStmt, `
			SELECT 'CREATE TABLE IF NOT EXISTS ' || tablename || ' (' || 
				string_agg(
					column_name || ' ' || 
					CASE 
						WHEN data_type = 'character varying' THEN 'VARCHAR(' || character_maximum_length || ')'
						WHEN data_type = 'numeric' THEN 'NUMERIC'
						WHEN data_type = 'timestamp without time zone' THEN 'TIMESTAMP'
						ELSE data_type
					END ||
					CASE WHEN is_nullable = 'NO' THEN ' NOT NULL' ELSE '' END ||
					CASE WHEN column_default IS NOT NULL THEN ' DEFAULT ' || column_default ELSE '' END,
					', '
				) || ');'
			FROM information_schema.columns
			WHERE table_name = $1 AND table_schema = 'public'
			GROUP BY tablename
		`, table)
		
		if err != nil {
			log.Printf("Failed to get structure for %s: %v", table, err)
			continue
		}
		
		file.WriteString(createStmt + "\n\n")
		
		// Get row count
		var count int
		err = db.Get(&count, fmt.Sprintf("SELECT COUNT(*) FROM %s", table))
		if err != nil {
			log.Printf("Failed to count rows in %s: %v", table, err)
			continue
		}
		
		if count == 0 {
			file.WriteString(fmt.Sprintf("-- No data in table %s\n", table))
			continue
		}
		
		file.WriteString(fmt.Sprintf("-- Data for table %s (%d rows)\n", table, count))
		
		// Export data (simplified for common tables)
		switch table {
		case "users", "buses", "vehicles", "routes", "students", "maintenance_records":
			exportTableData(db, file, table)
		default:
			file.WriteString(fmt.Sprintf("-- Skipping data export for %s (manual export needed)\n", table))
		}
	}
	
	fmt.Println("\nExport completed to railway_export.sql")
	fmt.Println("\nTo import locally:")
	fmt.Println("1. Install PostgreSQL locally")
	fmt.Println("2. Create a database: createdb fleet_management")
	fmt.Println("3. Import the data: psql fleet_management < railway_export.sql")
}

func exportTableData(db *sqlx.DB, file *os.File, table string) {
	// Get all columns
	var columns []string
	err := db.Select(&columns, `
		SELECT column_name 
		FROM information_schema.columns 
		WHERE table_name = $1 AND table_schema = 'public'
		ORDER BY ordinal_position
	`, table)
	if err != nil {
		log.Printf("Failed to get columns for %s: %v", table, err)
		return
	}
	
	// Build query
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(columns, ", "), table)
	
	rows, err := db.Query(query)
	if err != nil {
		log.Printf("Failed to query %s: %v", table, err)
		return
	}
	defer rows.Close()
	
	// Get column types (not used but kept for potential future use)
	_, err = rows.ColumnTypes()
	if err != nil {
		log.Printf("Failed to get column types for %s: %v", table, err)
		return
	}
	
	// Prepare value holders
	values := make([]interface{}, len(columns))
	valuePtrs := make([]interface{}, len(columns))
	for i := range values {
		valuePtrs[i] = &values[i]
	}
	
	// Export rows
	rowCount := 0
	for rows.Next() {
		err := rows.Scan(valuePtrs...)
		if err != nil {
			log.Printf("Failed to scan row in %s: %v", table, err)
			continue
		}
		
		// Build INSERT statement
		var valueStrings []string
		for _, v := range values {
			switch v := v.(type) {
			case nil:
				valueStrings = append(valueStrings, "NULL")
			case string:
				// Escape single quotes
				escaped := strings.ReplaceAll(v, "'", "''")
				valueStrings = append(valueStrings, fmt.Sprintf("'%s'", escaped))
			case []byte:
				// Handle byte arrays (like JSONB)
				escaped := strings.ReplaceAll(string(v), "'", "''")
				valueStrings = append(valueStrings, fmt.Sprintf("'%s'", escaped))
			case bool:
				if v {
					valueStrings = append(valueStrings, "TRUE")
				} else {
					valueStrings = append(valueStrings, "FALSE")
				}
			default:
				valueStrings = append(valueStrings, fmt.Sprintf("%v", v))
			}
		}
		
		insertStmt := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s);\n", 
			table, 
			strings.Join(columns, ", "), 
			strings.Join(valueStrings, ", "))
		
		file.WriteString(insertStmt)
		rowCount++
	}
	
	file.WriteString(fmt.Sprintf("-- Exported %d rows for %s\n\n", rowCount, table))
}